# 高级模式

探索 Claude Code Skills 的高级设计模式和架构。

## 协调器-工作者模式

**模式**: Orchestrator-Worker

**适用场景**: 复杂的多步骤任务，需要协调多个操作

### 概念

```text
┌─────────────┐
│ 协调器      │
│ (Orchestrator)│
└──────┬──────┘
       │
       ├──> 工作者 1 ──> 结果 1
       ├──> 工作者 2 ──> 结果 2
       └──> 工作者 3 ──> 结果 3
              │
              ▼
         汇总结果
```

### 实现

```markdown
# 协调器 Skill

---
name: data-pipeline
description: 协调多个数据处理步骤
allowed-tools:
  - Read
  - Write
  - Bash
---

# 数据处理管道

你是数据处理协调器，管理多个处理步骤。

## 工作流程

### 第 1 步: 读取数据
使用 Read 工具读取原始数据

### 第 2 步: 协调处理
调用不同的工作者：

#### 工作者 1: 数据清洗
- 移除重复项
- 处理缺失值
- 标准化格式

#### 工作者 2: 数据转换
- 转换数据类型
- 计算衍生字段
- 应用业务规则

#### 工作者 3: 数据验证
- 检查数据完整性
- 验证业务规则
- 记录验证结果

### 第 3 步: 汇总结果
收集所有工作者的结果
- 成功处理的记录数
- 失败的记录数
- 警告和错误

### 第 4 步: 保存结果
将处理后的数据保存到文件
```

### 优势

- ✅ 清晰的职责分离
- ✅ 易于测试每个工作者
- ✅ 可以独立优化每个步骤
- ✅ 易于扩展新功能

## 反馈循环模式

**模式**: Feedback Loop

**适用场景**: 需要根据结果调整行为的任务

### 概念

```text
    ┌──────┐
    │ 执行 │
    └──┬───┘
       │
       ▼
    ┌──────┐
    │ 检查 │◀─────┐
    └──┬───┘      │
       │         │
       ▼         │
    ┌──────┐     │
    │ 调整 │─────┘
    └──────┘
```

### 实现

```markdown
# 代码优化器

---
name: code-optimizer
description: 迭代优化代码直到满足质量标准
allowed-tools:
  - Read
  - Write
  - Grep
---

# 代码优化器

你是代码优化专家，通过迭代改进代码质量。

## 工作流程

### 初始化
1. 读取原始代码
2. 分析代码质量
3. 设置质量目标

### 迭代优化

循环执行以下步骤，直到满足目标：

#### 第 1 轮迭代
**当前质量**: 60/100

**问题**:
- 函数太长
- 缺少注释
- 命名不清晰

**优化**:
- 拆分函数
- 添加注释
- 改进命名

#### 第 2 轮迭代
**当前质量**: 75/100

**问题**:
- 复杂度仍然较高
- 错误处理不足

**优化**:
- 简化逻辑
- 添加错误处理

#### 第 3 轮迭代
**当前质量**: 90/100 ✓

**目标达成**: 质量达到 85+ 分

### 输出最终结果
显示优化后的代码和改进说明
```

## 条件工作流模式

**模式**: Conditional Workflow

**适用场景**: 根据条件执行不同的流程

### 实现

```markdown
# 智能部署助手

---
name: deploy-helper
description: 根据项目类型选择合适的部署策略
allowed-tools:
  - Read
  - Bash
  - Glob
---

# 部署助手

你是智能部署专家，根据项目类型选择最佳部署策略。

## 工作流程

### 第 1 步: 识别项目类型

检测项目特征：

#### A) Node.js 项目
- 存在 `package.json`
- 有 `node_modules/` 目录

#### B) Python 项目
- 存在 `requirements.txt` 或 `setup.py`
- 有 `.py` 文件

#### C) 静态网站
- 有 `index.html`
- 有 CSS/JS 文件

#### D) Docker 项目
- 存在 `Dockerfile`
- 有 `docker-compose.yml`

### 第 2 步: 选择部署流程

#### 流程 A: Node.js 部署
1. 安装依赖: `npm install`
2. 运行测试: `npm test`
3. 构建: `npm run build`
4. 部署到服务器

#### 流程 B: Python 部署
1. 创建虚拟环境
2. 安装依赖
3. 运行测试
4. 部署

#### 流程 C: 静态网站部署
1. 优化资源
2. 上传到 CDN
3. 配置缓存

#### 流程 D: Docker 部署
1. 构建镜像
2. 推送到 registry
3. 更新服务

### 第 3 步: 执行部署
按照选定的流程执行部署

### 第 4 步: 验证部署
检查部署是否成功
```

## 多代理协作模式

**模式**: Multi-Agent Collaboration

**适用场景**: 需要多个专业 Agent 协作

### 概念

```text
┌─────────────┐     ┌─────────────┐
│ Agent 1     │     │ Agent 2     │
│ (代码分析)  │     │ (测试专家)  │
└──────┬──────┘     └──────┬──────┘
       │                   │
       └────────┬──────────┘
                │
        ┌───────▼───────┐
        │  协调 Agent   │
        │  (汇总结果)   │
        └───────────────┘
```

### 实现

```markdown
# 代码审查协调器

---
name: review-coordinator
description: 协调多个专家 Agent 进行全面代码审查
context: fork
agent: general-purpose
---

# 代码审查协调器

你是代码审查协调器，组织多个专家 Agent 进行全面审查。

## 专家团队

### Agent 1: 安全专家
关注安全漏洞：
- SQL 注入
- XSS 漏洞
- 认证问题

### Agent 2: 性能专家
关注性能问题：
- 算法复杂度
- 内存使用
- 数据库查询

### Agent 3: 可维护性专家
关注代码质量：
- 命名规范
- 代码结构
- 文档完整性

## 工作流程

### 第 1 步: 读取代码
获取要审查的代码

### 第 2 步: 分配任务
将代码分配给各专家 Agent

### 第 3 步: 收集反馈
等待并收集每个专家的意见

### 第 4 步: 汇总报告
整合所有反馈：
- 优先级排序
- 去除重复
- 统一格式

### 第 5 步: 输出报告
生成完整的审查报告
```

## 状态机模式

**模式**: State Machine

**适用场景**: 有明确状态转换的任务

### 实现

```markdown
# 部署状态管理

---
name: deployment-manager
description: 管理部署流程的状态和转换
allowed-tools:
  - Read
  - Write
  - Bash
---

# 部署管理器

你是部署管理专家，管理部署的完整生命周期。

## 状态定义

```text

┌─────────┐
│ PENDING │ (待处理)
└────┬────┘
     │
     ▼
┌─────────┐
│BUILDING │ (构建中)
└────┬────┘
     │
     ▼
┌─────────┐
│TESTING  │ (测试中)
└────┬────┘
     │
     ├─> FAILED (失败) ──> PENDING
     │
     ▼
┌─────────┐
│DEPLOYING│ (部署中)
└────┬────┘
     │
     ├─> FAILED (失败) ──> PENDING
     │
     ▼
┌─────────┐
│ SUCCESS │ (成功)
└─────────┘

```

## 状态转换规则

### PENDING → BUILDING
- 触发: 开始部署
- 操作: 启动构建流程

### BUILDING → TESTING
- 触发: 构建成功
- 操作: 运行测试套件

### BUILDING → FAILED
- 触发: 构建失败
- 操作: 记录日志，返回 PENDING

### TESTING → DEPLOYING
- 触发: 测试通过
- 操作: 开始部署

### TESTING → FAILED
- 触发: 测试失败
- 操作: 记录失败，返回 PENDING

### DEPLOYING → SUCCESS
- 触发: 部署完成
- 操作: 更新状态，通知用户

### DEPLOYING → FAILED
- 触发: 部署失败
- 操作: 回滚，返回 PENDING

## 工作流程

### 1. 检查当前状态
读取状态文件

### 2. 根据状态执行操作
每个状态有对应的操作

### 3. 转换到下一状态
根据结果转换状态

### 4. 保存状态
更新状态文件

### 5. 重复直到 SUCCESS 或 FAILED
```

## 管道模式

**模式**: Pipeline

**适用场景**: 数据流处理

### 实现

```markdown
# 日志分析管道

---
name: log-pipeline
description: 多阶段处理日志数据
allowed-tools:
  - Read
  - Write
  - Bash
---

# 日志分析管道

你是日志分析专家，通过管道处理日志数据。

## 管道阶段

```text

原始日志
   │
   ▼
[阶段 1: 解析]
   │
   ▼
[阶段 2: 过滤]
   │
   ▼
[阶段 3: 聚合]
   │
   ▼
[阶段 4: 格式化]
   │
   ▼
分析报告

```

### 阶段 1: 解析
- 读取原始日志
- 解析日志格式
- 提取字段

### 阶段 2: 过滤
- 移除无关日志
- 按时间范围过滤
- 按级别过滤

### 阶段 3: 聚合
- 统计错误数量
- 按类型分组
- 计算趋势

### 阶段 4: 格式化
- 生成报告
- 创建图表
- 导出结果

## 执行流程

顺序执行每个阶段，传递数据到下一阶段。
```

## 选择合适的模式

### 决策树

```text
需要协调多个操作？
├─ 是 → 协调器-工作者模式
└─ 否 →
    需要根据结果调整？
    ├─ 是 → 反馈循环模式
    └─ 否 →
        有明确的条件分支？
        ├─ 是 → 条件工作流模式
        └─ 否 →
            数据需要多个处理阶段？
            ├─ 是 → 管道模式
            └─ 否 →
                有复杂的状态转换？
                └─ 是 → 状态机模式
```

## 最佳实践

### 1. 保持简单

不要过度设计，选择最简单的模式满足需求

### 2. 清晰的接口

每个组件/阶段有清晰的输入输出

### 3. 错误处理

每个模式都要考虑错误情况

### 4. 可测试性

设计时要考虑测试的便利性

## 总结

高级模式的关键点：

1. **协调器-工作者** - 分离关注点
2. **反馈循环** - 迭代改进
3. **条件工作流** - 灵活处理
4. **多代理协作** - 专业分工
5. **状态机** - 明确状态
6. **管道** - 流式处理

## 下一步

1. **练习**：[高级练习 11：协调器模式](../../exercises/advanced/exercise-11-orchestrator.md)
2. **实践**：创建使用高级模式的 Skill
3. **参考**：查看 [高级示例 Skills](../../skills/11-advanced-patterns/)

## 参考资源

- [最佳实践](03-best-practices.md)
- [教程：工作流设计](tutorials/tutorial-03-workflow-design.md)
- [设计模式：重构](reference/patterns.md)
